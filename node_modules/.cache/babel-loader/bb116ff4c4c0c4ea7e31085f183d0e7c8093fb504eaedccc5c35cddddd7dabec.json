{"ast":null,"code":"import * as THREE from 'three';\n\n// Mapeamento de modelos para suas texturas\nconst modelTextureMap = {\n  'archer.fbx': 'archer.png',\n  'warrior.fbx': 'warrior.png',\n  'wizard.fbx': 'wizard.png'\n};\n\n// Configurações de textura para cada modelo\nconst textureSettings = {\n  'archer.fbx': {\n    repeat: new THREE.Vector2(1, 1),\n    // Repetição da textura\n    offset: new THREE.Vector2(0, 0),\n    // Deslocamento da textura\n    rotation: 0,\n    // Rotação em radianos\n    center: new THREE.Vector2(0.5, 0.5) // Centro de rotação\n  },\n  'warrior.fbx': {\n    repeat: new THREE.Vector2(1, 1),\n    offset: new THREE.Vector2(0, 0),\n    rotation: 0,\n    center: new THREE.Vector2(0.5, 0.5)\n  },\n  'wizard.fbx': {\n    repeat: new THREE.Vector2(1, 1),\n    offset: new THREE.Vector2(0, 0),\n    rotation: 0,\n    center: new THREE.Vector2(0.5, 0.5)\n  }\n};\n\n/**\r\n * Aplica textura a um modelo FBX\r\n * @param {THREE.Object3D} model - O modelo FBX carregado\r\n * @param {string} modelName - Nome do arquivo do modelo (ex: 'archer.fbx')\r\n * @returns {Promise} - Promise que resolve quando a textura é aplicada\r\n */\nexport const applyTextureToModel = (model, modelName) => {\n  return new Promise((resolve, reject) => {\n    const textureName = modelTextureMap[modelName];\n    if (!textureName) {\n      console.warn(`No texture mapping found for model: ${modelName}`);\n      resolve(model);\n      return;\n    }\n    const textureLoader = new THREE.TextureLoader();\n    const texturePath = `/assets/textures/${textureName}`;\n    textureLoader.load(texturePath, texture => {\n      // Configurar a textura\n      texture.colorSpace = THREE.SRGBColorSpace;\n      texture.flipY = false; // Importante para texturas FBX\n\n      // Aplicar configurações de transformação da textura\n      const settings = textureSettings[modelName] || textureSettings['archer.fbx'];\n      texture.repeat.copy(settings.repeat);\n      texture.offset.copy(settings.offset);\n      texture.rotation = settings.rotation;\n      texture.center.copy(settings.center);\n\n      // Configurar wrapping da textura\n      texture.wrapS = THREE.RepeatWrapping;\n      texture.wrapT = THREE.RepeatWrapping;\n\n      // Aplicar a textura a todos os meshes do modelo\n      model.traverse(child => {\n        if (child.isMesh) {\n          // Criar novo material com a textura\n          const material = new THREE.MeshStandardMaterial({\n            map: texture,\n            roughness: 0.7,\n            metalness: 0.3\n          });\n          child.material = material;\n        }\n      });\n      resolve(model);\n    }, undefined, error => {\n      console.error(`Error loading texture for ${modelName}:`, error);\n      reject(error);\n    });\n  });\n};\n\n/**\r\n * Carrega e aplica textura a um modelo FBX\r\n * @param {THREE.Object3D} model - O modelo FBX carregado\r\n * @param {string} modelName - Nome do arquivo do modelo\r\n * @returns {Promise} - Promise que resolve com o modelo texturizado\r\n */\nexport const loadAndApplyTexture = async (model, modelName) => {\n  try {\n    const texturedModel = await applyTextureToModel(model, modelName);\n    return texturedModel;\n  } catch (error) {\n    console.error(`Failed to apply texture to ${modelName}:`, error);\n    return model; // Retorna o modelo original em caso de erro\n  }\n};","map":{"version":3,"names":["THREE","modelTextureMap","textureSettings","repeat","Vector2","offset","rotation","center","applyTextureToModel","model","modelName","Promise","resolve","reject","textureName","console","warn","textureLoader","TextureLoader","texturePath","load","texture","colorSpace","SRGBColorSpace","flipY","settings","copy","wrapS","RepeatWrapping","wrapT","traverse","child","isMesh","material","MeshStandardMaterial","map","roughness","metalness","undefined","error","loadAndApplyTexture","texturedModel"],"sources":["M:/DemoGame/src/utils/textureLoader.js"],"sourcesContent":["import * as THREE from 'three';\r\n\r\n// Mapeamento de modelos para suas texturas\r\nconst modelTextureMap = {\r\n  'archer.fbx': 'archer.png',\r\n  'warrior.fbx': 'warrior.png',\r\n  'wizard.fbx': 'wizard.png'\r\n};\r\n\r\n// Configurações de textura para cada modelo\r\nconst textureSettings = {\r\n  'archer.fbx': {\r\n    repeat: new THREE.Vector2(1, 1),    // Repetição da textura\r\n    offset: new THREE.Vector2(0, 0),    // Deslocamento da textura\r\n    rotation: 0,                        // Rotação em radianos\r\n    center: new THREE.Vector2(0.5, 0.5) // Centro de rotação\r\n  },\r\n  'warrior.fbx': {\r\n    repeat: new THREE.Vector2(1, 1),\r\n    offset: new THREE.Vector2(0, 0),\r\n    rotation: 0,\r\n    center: new THREE.Vector2(0.5, 0.5)\r\n  },\r\n  'wizard.fbx': {\r\n    repeat: new THREE.Vector2(1, 1),\r\n    offset: new THREE.Vector2(0, 0),\r\n    rotation: 0,\r\n    center: new THREE.Vector2(0.5, 0.5)\r\n  }\r\n};\r\n\r\n/**\r\n * Aplica textura a um modelo FBX\r\n * @param {THREE.Object3D} model - O modelo FBX carregado\r\n * @param {string} modelName - Nome do arquivo do modelo (ex: 'archer.fbx')\r\n * @returns {Promise} - Promise que resolve quando a textura é aplicada\r\n */\r\nexport const applyTextureToModel = (model, modelName) => {\r\n  return new Promise((resolve, reject) => {\r\n    const textureName = modelTextureMap[modelName];\r\n    if (!textureName) {\r\n      console.warn(`No texture mapping found for model: ${modelName}`);\r\n      resolve(model);\r\n      return;\r\n    }\r\n\r\n    const textureLoader = new THREE.TextureLoader();\r\n    const texturePath = `/assets/textures/${textureName}`;\r\n\r\n    textureLoader.load(\r\n      texturePath,\r\n      (texture) => {\r\n        // Configurar a textura\r\n        texture.colorSpace = THREE.SRGBColorSpace;\r\n        texture.flipY = false; // Importante para texturas FBX\r\n\r\n        // Aplicar configurações de transformação da textura\r\n        const settings = textureSettings[modelName] || textureSettings['archer.fbx'];\r\n        texture.repeat.copy(settings.repeat);\r\n        texture.offset.copy(settings.offset);\r\n        texture.rotation = settings.rotation;\r\n        texture.center.copy(settings.center);\r\n        \r\n        // Configurar wrapping da textura\r\n        texture.wrapS = THREE.RepeatWrapping;\r\n        texture.wrapT = THREE.RepeatWrapping;\r\n\r\n        // Aplicar a textura a todos os meshes do modelo\r\n        model.traverse((child) => {\r\n          if (child.isMesh) {\r\n            // Criar novo material com a textura\r\n            const material = new THREE.MeshStandardMaterial({\r\n              map: texture,\r\n              roughness: 0.7,\r\n              metalness: 0.3\r\n            });\r\n            child.material = material;\r\n          }\r\n        });\r\n\r\n        resolve(model);\r\n      },\r\n      undefined,\r\n      (error) => {\r\n        console.error(`Error loading texture for ${modelName}:`, error);\r\n        reject(error);\r\n      }\r\n    );\r\n  });\r\n};\r\n\r\n/**\r\n * Carrega e aplica textura a um modelo FBX\r\n * @param {THREE.Object3D} model - O modelo FBX carregado\r\n * @param {string} modelName - Nome do arquivo do modelo\r\n * @returns {Promise} - Promise que resolve com o modelo texturizado\r\n */\r\nexport const loadAndApplyTexture = async (model, modelName) => {\r\n  try {\r\n    const texturedModel = await applyTextureToModel(model, modelName);\r\n    return texturedModel;\r\n  } catch (error) {\r\n    console.error(`Failed to apply texture to ${modelName}:`, error);\r\n    return model; // Retorna o modelo original em caso de erro\r\n  }\r\n}; "],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;;AAE9B;AACA,MAAMC,eAAe,GAAG;EACtB,YAAY,EAAE,YAAY;EAC1B,aAAa,EAAE,aAAa;EAC5B,YAAY,EAAE;AAChB,CAAC;;AAED;AACA,MAAMC,eAAe,GAAG;EACtB,YAAY,EAAE;IACZC,MAAM,EAAE,IAAIH,KAAK,CAACI,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IAAK;IACpCC,MAAM,EAAE,IAAIL,KAAK,CAACI,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IAAK;IACpCE,QAAQ,EAAE,CAAC;IAAyB;IACpCC,MAAM,EAAE,IAAIP,KAAK,CAACI,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;EACtC,CAAC;EACD,aAAa,EAAE;IACbD,MAAM,EAAE,IAAIH,KAAK,CAACI,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IAC/BC,MAAM,EAAE,IAAIL,KAAK,CAACI,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IAC/BE,QAAQ,EAAE,CAAC;IACXC,MAAM,EAAE,IAAIP,KAAK,CAACI,OAAO,CAAC,GAAG,EAAE,GAAG;EACpC,CAAC;EACD,YAAY,EAAE;IACZD,MAAM,EAAE,IAAIH,KAAK,CAACI,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IAC/BC,MAAM,EAAE,IAAIL,KAAK,CAACI,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;IAC/BE,QAAQ,EAAE,CAAC;IACXC,MAAM,EAAE,IAAIP,KAAK,CAACI,OAAO,CAAC,GAAG,EAAE,GAAG;EACpC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMI,mBAAmB,GAAGA,CAACC,KAAK,EAAEC,SAAS,KAAK;EACvD,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,MAAMC,WAAW,GAAGb,eAAe,CAACS,SAAS,CAAC;IAC9C,IAAI,CAACI,WAAW,EAAE;MAChBC,OAAO,CAACC,IAAI,CAAC,uCAAuCN,SAAS,EAAE,CAAC;MAChEE,OAAO,CAACH,KAAK,CAAC;MACd;IACF;IAEA,MAAMQ,aAAa,GAAG,IAAIjB,KAAK,CAACkB,aAAa,CAAC,CAAC;IAC/C,MAAMC,WAAW,GAAG,oBAAoBL,WAAW,EAAE;IAErDG,aAAa,CAACG,IAAI,CAChBD,WAAW,EACVE,OAAO,IAAK;MACX;MACAA,OAAO,CAACC,UAAU,GAAGtB,KAAK,CAACuB,cAAc;MACzCF,OAAO,CAACG,KAAK,GAAG,KAAK,CAAC,CAAC;;MAEvB;MACA,MAAMC,QAAQ,GAAGvB,eAAe,CAACQ,SAAS,CAAC,IAAIR,eAAe,CAAC,YAAY,CAAC;MAC5EmB,OAAO,CAAClB,MAAM,CAACuB,IAAI,CAACD,QAAQ,CAACtB,MAAM,CAAC;MACpCkB,OAAO,CAAChB,MAAM,CAACqB,IAAI,CAACD,QAAQ,CAACpB,MAAM,CAAC;MACpCgB,OAAO,CAACf,QAAQ,GAAGmB,QAAQ,CAACnB,QAAQ;MACpCe,OAAO,CAACd,MAAM,CAACmB,IAAI,CAACD,QAAQ,CAAClB,MAAM,CAAC;;MAEpC;MACAc,OAAO,CAACM,KAAK,GAAG3B,KAAK,CAAC4B,cAAc;MACpCP,OAAO,CAACQ,KAAK,GAAG7B,KAAK,CAAC4B,cAAc;;MAEpC;MACAnB,KAAK,CAACqB,QAAQ,CAAEC,KAAK,IAAK;QACxB,IAAIA,KAAK,CAACC,MAAM,EAAE;UAChB;UACA,MAAMC,QAAQ,GAAG,IAAIjC,KAAK,CAACkC,oBAAoB,CAAC;YAC9CC,GAAG,EAAEd,OAAO;YACZe,SAAS,EAAE,GAAG;YACdC,SAAS,EAAE;UACb,CAAC,CAAC;UACFN,KAAK,CAACE,QAAQ,GAAGA,QAAQ;QAC3B;MACF,CAAC,CAAC;MAEFrB,OAAO,CAACH,KAAK,CAAC;IAChB,CAAC,EACD6B,SAAS,EACRC,KAAK,IAAK;MACTxB,OAAO,CAACwB,KAAK,CAAC,6BAA6B7B,SAAS,GAAG,EAAE6B,KAAK,CAAC;MAC/D1B,MAAM,CAAC0B,KAAK,CAAC;IACf,CACF,CAAC;EACH,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,mBAAmB,GAAG,MAAAA,CAAO/B,KAAK,EAAEC,SAAS,KAAK;EAC7D,IAAI;IACF,MAAM+B,aAAa,GAAG,MAAMjC,mBAAmB,CAACC,KAAK,EAAEC,SAAS,CAAC;IACjE,OAAO+B,aAAa;EACtB,CAAC,CAAC,OAAOF,KAAK,EAAE;IACdxB,OAAO,CAACwB,KAAK,CAAC,8BAA8B7B,SAAS,GAAG,EAAE6B,KAAK,CAAC;IAChE,OAAO9B,KAAK,CAAC,CAAC;EAChB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}