{"ast":null,"code":"import * as THREE from 'three';\n\n// Mapeamento de modelos para suas texturas\nconst modelTextureMap = {\n  'archer.fbx': {\n    diffuse: 'archer/texture_diffuse.png',\n    normal: 'archer/texture_normal.png',\n    metallic: 'archer/texture_metallic.png',\n    roughness: 'archer/texture_roughness.png',\n    pbr: 'archer/texture_pbr.png'\n  },\n  'warrior.fbx': {\n    diffuse: 'warrior/texture_diffuse.png',\n    normal: 'warrior/texture_normal.png',\n    metallic: 'warrior/texture_metallic.png',\n    roughness: 'warrior/texture_roughness.png',\n    pbr: 'warrior/texture_pbr.png'\n  },\n  'wizard.fbx': {\n    diffuse: 'wizard/texture_diffuse.png',\n    normal: 'wizard/texture_normal.png',\n    metallic: 'wizard/texture_metallic.png',\n    roughness: 'wizard/texture_roughness.png',\n    pbr: 'wizard/texture_pbr.png'\n  }\n};\n\n/**\r\n * Configura uma textura com as propriedades corretas\r\n * @param {THREE.Texture} texture - A textura a ser configurada\r\n * @param {number} scale - Fator de escala do modelo\r\n * @returns {THREE.Texture} - A textura configurada\r\n */\nconst configureTexture = (texture, scale) => {\n  texture.colorSpace = THREE.SRGBColorSpace;\n  texture.flipY = false;\n  texture.wrapS = THREE.RepeatWrapping;\n  texture.wrapT = THREE.RepeatWrapping;\n\n  // Ajustar a repetição da textura baseado na escala\n  const repeat = 1 / scale;\n  texture.repeat.set(repeat, repeat);\n  texture.offset.set(0, 0);\n  texture.rotation = 0;\n  texture.center.set(0.5, 0.5);\n  return texture;\n};\n\n/**\r\n * Aplica textura a um modelo FBX\r\n * @param {THREE.Object3D} model - O modelo FBX carregado\r\n * @param {string} modelName - Nome do arquivo do modelo (ex: 'archer.fbx')\r\n * @returns {Promise} - Promise que resolve quando a textura é aplicada\r\n */\nexport const applyTextureToModel = (model, modelName) => {\n  return new Promise((resolve, reject) => {\n    const textureMaps = modelTextureMap[modelName];\n    if (!textureMaps) {\n      console.warn(`No texture mapping found for model: ${modelName}`);\n      resolve(model);\n      return;\n    }\n    console.log(`Loading textures for ${modelName}...`);\n\n    // Calcular a escala do modelo\n    const bbox = new THREE.Box3().setFromObject(model);\n    const size = bbox.getSize(new THREE.Vector3());\n    const maxDim = Math.max(size.x, size.y, size.z);\n    const scale = model.scale.x; // Assumindo que a escala é uniforme (x = y = z)\n\n    console.log(`Model scale factor: ${scale}`);\n    const textureLoader = new THREE.TextureLoader();\n    const loadTexture = path => {\n      return new Promise((resolve, reject) => {\n        textureLoader.load(`/assets/textures/${path}`, texture => {\n          console.log(`Loaded texture: ${path}`);\n          resolve(configureTexture(texture, scale));\n        }, undefined, error => {\n          console.error(`Error loading texture ${path}:`, error);\n          reject(error);\n        });\n      });\n    };\n\n    // Carregar todas as texturas\n    Promise.all([loadTexture(textureMaps.diffuse), loadTexture(textureMaps.normal), loadTexture(textureMaps.metallic), loadTexture(textureMaps.roughness), loadTexture(textureMaps.pbr)]).then(([diffuseMap, normalMap, metallicMap, roughnessMap, pbrMap]) => {\n      console.log('All textures loaded, applying to model...');\n\n      // Aplicar as texturas a todos os meshes do modelo\n      model.traverse(child => {\n        if (child.isMesh) {\n          console.log(`Applying textures to mesh: ${child.name}`);\n\n          // Criar novo material PBR\n          const material = new THREE.MeshStandardMaterial({\n            map: diffuseMap,\n            // Textura de cor base\n            normalMap: normalMap,\n            // Mapa de normais para detalhes de superfície\n            metalnessMap: metallicMap,\n            // Mapa de metalicidade\n            roughnessMap: roughnessMap,\n            // Mapa de rugosidade\n            aoMap: pbrMap,\n            // Mapa de oclusão ambiente\n            aoMapIntensity: 1.0,\n            // Intensidade da oclusão ambiente\n            normalScale: new THREE.Vector2(1, 1),\n            // Escala do mapa de normais\n            roughness: 1.0,\n            // Rugosidade base\n            metalness: 1.0 // Metalicidade base\n          });\n\n          // Configurar o material\n          material.needsUpdate = true;\n          child.material = material;\n\n          // Log das propriedades do material para debug\n          console.log('Material properties:', {\n            hasDiffuseMap: !!material.map,\n            hasNormalMap: !!material.normalMap,\n            hasMetallicMap: !!material.metalnessMap,\n            hasRoughnessMap: !!material.roughnessMap,\n            hasAoMap: !!material.aoMap,\n            textureRepeat: material.map.repeat\n          });\n        }\n      });\n      console.log('Textures applied successfully');\n      resolve(model);\n    }).catch(error => {\n      console.error(`Error loading textures for ${modelName}:`, error);\n      reject(error);\n    });\n  });\n};\n\n/**\r\n * Carrega e aplica textura a um modelo FBX\r\n * @param {THREE.Object3D} model - O modelo FBX carregado\r\n * @param {string} modelName - Nome do arquivo do modelo\r\n * @returns {Promise} - Promise que resolve com o modelo texturizado\r\n */\nexport const loadAndApplyTexture = async (model, modelName) => {\n  try {\n    const texturedModel = await applyTextureToModel(model, modelName);\n    return texturedModel;\n  } catch (error) {\n    console.error(`Failed to apply texture to ${modelName}:`, error);\n    return model; // Retorna o modelo original em caso de erro\n  }\n};","map":{"version":3,"names":["THREE","modelTextureMap","diffuse","normal","metallic","roughness","pbr","configureTexture","texture","scale","colorSpace","SRGBColorSpace","flipY","wrapS","RepeatWrapping","wrapT","repeat","set","offset","rotation","center","applyTextureToModel","model","modelName","Promise","resolve","reject","textureMaps","console","warn","log","bbox","Box3","setFromObject","size","getSize","Vector3","maxDim","Math","max","x","y","z","textureLoader","TextureLoader","loadTexture","path","load","undefined","error","all","then","diffuseMap","normalMap","metallicMap","roughnessMap","pbrMap","traverse","child","isMesh","name","material","MeshStandardMaterial","map","metalnessMap","aoMap","aoMapIntensity","normalScale","Vector2","metalness","needsUpdate","hasDiffuseMap","hasNormalMap","hasMetallicMap","hasRoughnessMap","hasAoMap","textureRepeat","catch","loadAndApplyTexture","texturedModel"],"sources":["M:/DemoGame/src/utils/textureLoader.js"],"sourcesContent":["import * as THREE from 'three';\r\n\r\n// Mapeamento de modelos para suas texturas\r\nconst modelTextureMap = {\r\n  'archer.fbx': {\r\n    diffuse: 'archer/texture_diffuse.png',\r\n    normal: 'archer/texture_normal.png',\r\n    metallic: 'archer/texture_metallic.png',\r\n    roughness: 'archer/texture_roughness.png',\r\n    pbr: 'archer/texture_pbr.png'\r\n  },\r\n  'warrior.fbx': {\r\n    diffuse: 'warrior/texture_diffuse.png',\r\n    normal: 'warrior/texture_normal.png',\r\n    metallic: 'warrior/texture_metallic.png',\r\n    roughness: 'warrior/texture_roughness.png',\r\n    pbr: 'warrior/texture_pbr.png'\r\n  },\r\n  'wizard.fbx': {\r\n    diffuse: 'wizard/texture_diffuse.png',\r\n    normal: 'wizard/texture_normal.png',\r\n    metallic: 'wizard/texture_metallic.png',\r\n    roughness: 'wizard/texture_roughness.png',\r\n    pbr: 'wizard/texture_pbr.png'\r\n  }\r\n};\r\n\r\n/**\r\n * Configura uma textura com as propriedades corretas\r\n * @param {THREE.Texture} texture - A textura a ser configurada\r\n * @param {number} scale - Fator de escala do modelo\r\n * @returns {THREE.Texture} - A textura configurada\r\n */\r\nconst configureTexture = (texture, scale) => {\r\n  texture.colorSpace = THREE.SRGBColorSpace;\r\n  texture.flipY = false;\r\n  texture.wrapS = THREE.RepeatWrapping;\r\n  texture.wrapT = THREE.RepeatWrapping;\r\n  \r\n  // Ajustar a repetição da textura baseado na escala\r\n  const repeat = 1 / scale;\r\n  texture.repeat.set(repeat, repeat);\r\n  \r\n  texture.offset.set(0, 0);\r\n  texture.rotation = 0;\r\n  texture.center.set(0.5, 0.5);\r\n  return texture;\r\n};\r\n\r\n/**\r\n * Aplica textura a um modelo FBX\r\n * @param {THREE.Object3D} model - O modelo FBX carregado\r\n * @param {string} modelName - Nome do arquivo do modelo (ex: 'archer.fbx')\r\n * @returns {Promise} - Promise que resolve quando a textura é aplicada\r\n */\r\nexport const applyTextureToModel = (model, modelName) => {\r\n  return new Promise((resolve, reject) => {\r\n    const textureMaps = modelTextureMap[modelName];\r\n    if (!textureMaps) {\r\n      console.warn(`No texture mapping found for model: ${modelName}`);\r\n      resolve(model);\r\n      return;\r\n    }\r\n\r\n    console.log(`Loading textures for ${modelName}...`);\r\n\r\n    // Calcular a escala do modelo\r\n    const bbox = new THREE.Box3().setFromObject(model);\r\n    const size = bbox.getSize(new THREE.Vector3());\r\n    const maxDim = Math.max(size.x, size.y, size.z);\r\n    const scale = model.scale.x; // Assumindo que a escala é uniforme (x = y = z)\r\n    \r\n    console.log(`Model scale factor: ${scale}`);\r\n\r\n    const textureLoader = new THREE.TextureLoader();\r\n    const loadTexture = (path) => {\r\n      return new Promise((resolve, reject) => {\r\n        textureLoader.load(\r\n          `/assets/textures/${path}`,\r\n          (texture) => {\r\n            console.log(`Loaded texture: ${path}`);\r\n            resolve(configureTexture(texture, scale));\r\n          },\r\n          undefined,\r\n          (error) => {\r\n            console.error(`Error loading texture ${path}:`, error);\r\n            reject(error);\r\n          }\r\n        );\r\n      });\r\n    };\r\n\r\n    // Carregar todas as texturas\r\n    Promise.all([\r\n      loadTexture(textureMaps.diffuse),\r\n      loadTexture(textureMaps.normal),\r\n      loadTexture(textureMaps.metallic),\r\n      loadTexture(textureMaps.roughness),\r\n      loadTexture(textureMaps.pbr)\r\n    ])\r\n      .then(([diffuseMap, normalMap, metallicMap, roughnessMap, pbrMap]) => {\r\n        console.log('All textures loaded, applying to model...');\r\n        \r\n        // Aplicar as texturas a todos os meshes do modelo\r\n        model.traverse((child) => {\r\n          if (child.isMesh) {\r\n            console.log(`Applying textures to mesh: ${child.name}`);\r\n            \r\n            // Criar novo material PBR\r\n            const material = new THREE.MeshStandardMaterial({\r\n              map: diffuseMap,          // Textura de cor base\r\n              normalMap: normalMap,     // Mapa de normais para detalhes de superfície\r\n              metalnessMap: metallicMap, // Mapa de metalicidade\r\n              roughnessMap: roughnessMap, // Mapa de rugosidade\r\n              aoMap: pbrMap,            // Mapa de oclusão ambiente\r\n              aoMapIntensity: 1.0,      // Intensidade da oclusão ambiente\r\n              normalScale: new THREE.Vector2(1, 1), // Escala do mapa de normais\r\n              roughness: 1.0,           // Rugosidade base\r\n              metalness: 1.0,           // Metalicidade base\r\n            });\r\n\r\n            // Configurar o material\r\n            material.needsUpdate = true;\r\n            child.material = material;\r\n\r\n            // Log das propriedades do material para debug\r\n            console.log('Material properties:', {\r\n              hasDiffuseMap: !!material.map,\r\n              hasNormalMap: !!material.normalMap,\r\n              hasMetallicMap: !!material.metalnessMap,\r\n              hasRoughnessMap: !!material.roughnessMap,\r\n              hasAoMap: !!material.aoMap,\r\n              textureRepeat: material.map.repeat\r\n            });\r\n          }\r\n        });\r\n\r\n        console.log('Textures applied successfully');\r\n        resolve(model);\r\n      })\r\n      .catch((error) => {\r\n        console.error(`Error loading textures for ${modelName}:`, error);\r\n        reject(error);\r\n      });\r\n  });\r\n};\r\n\r\n/**\r\n * Carrega e aplica textura a um modelo FBX\r\n * @param {THREE.Object3D} model - O modelo FBX carregado\r\n * @param {string} modelName - Nome do arquivo do modelo\r\n * @returns {Promise} - Promise que resolve com o modelo texturizado\r\n */\r\nexport const loadAndApplyTexture = async (model, modelName) => {\r\n  try {\r\n    const texturedModel = await applyTextureToModel(model, modelName);\r\n    return texturedModel;\r\n  } catch (error) {\r\n    console.error(`Failed to apply texture to ${modelName}:`, error);\r\n    return model; // Retorna o modelo original em caso de erro\r\n  }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}